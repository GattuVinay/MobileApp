<LoginScreen>:
    BoxLayout:
        orientation: 'vertical'
        padding: [40, 20, 40, 50]  
        spacing: 20

        canvas.before:
            Rectangle:
                source: "image.png" 
                pos: self.pos
                size: self.size

        Label:
            text: "Greate Learning"
            font_size: 28
            bold: True
            color: 0, 0, 0, 1
            size_hint_y: None
            height: 50
            halign: "center"

        TextInput:
            id: user_id
            hint_text: "User ID"
            valign:'center'
            multiline: False
            write_tab: False
            size_hint_x: 0.8
            size_hint_y: None
            height: 50
            pos_hint: {"center_x": 0.5}

        TextInput:
            id: password
            hint_text: "Password"
            multiline: False
            write_tab: False
            password: True
            size_hint_x: 0.8
            size_hint_y: None
            height: 50
            pos_hint: {"center_x": 0.5}

        Label:
            id: login_message
            text: ""
            color: (1, 0, 0, 1)  # Red text for errors
            size_hint_y: None
            height: 20

        Button:
            text: "Login"
            size_hint_x: 0.6
            size_hint_y: None
            height: 50
            pos_hint: {"center_x": 0.5}
            on_press: root.validate_user()

        Button:
            text: "Exit"
            size_hint_x: 0.6
            size_hint_y: None
            height: 50
            pos_hint: {"center_x": 0.5}
            on_press: app.stop()

<ProfilePopup@Popup>:
    title: "User Profile"
    size_hint: 0.8, 0.6 
    auto_dismiss: True

    BoxLayout:
        orientation: 'vertical'
        padding: 20
        spacing: 20

        # Profile Picture
        FloatLayout:
            Image:
                source: 'Profile.png'  
                size_hint: None, None
                size: 150, 150
                allow_stretch: True
                keep_ratio: True
                halign: 'center'
                valign: 'middle'
                pos_hint: {"center_x": 0.5, "center_y": 0.5} 

        # User Name
        Label:
            id: user_name_label
            text: "[username]" 
            font_size: 20
            halign: 'center'
            valign: 'middle'
            text_size: self.size 

        # Close Button
        Button:
            text: "Close"
            size_hint_y: None
            height: 40
            on_press: root.dismiss()

<HomeScreen>:
    BoxLayout:
        orientation: 'vertical'
                
        canvas.before:
            Rectangle:
                source: "Backgroung.png"  
                pos: self.pos
                size: self.size

        # Navigation Bar
        BoxLayout:
            orientation: 'horizontal'
            size_hint_y: None
            height: 70
            padding: [10, 10]
            spacing: 25
            canvas.before:
                Color:
                    rgba: 0.1, 0.3, 0.6, 1  # Dark blue background for navigation bar
                Rectangle:
                    pos: self.pos
                    size: self.size

            Label:
                text: "Dashboard"
                font_size: 24
                color: 1, 1, 1, 1
                halign: 'left'
                valign: 'center'
                size_hint_x: 0.8

            Button:
                text: "Profile"
                size_hint: 0.45, 0.9
                size: 70, 70          # Width and height of the rectangle
                on_press: app.show_profile_popup()

        # Main Content
        BoxLayout:
            orientation: 'vertical'
            spacing: 125
            padding: [20, 20]

            GridLayout:
                cols: 3  # Three columns for icons
                spacing: 110
                padding: [80, 40]
                size_hint_y: None
                height: 200

                Button:
                    background_normal: 'automata_icon.png' 
                    size_hint: None, None
                    size: 200,200
                    color: 0, 0, 0, 1  # Black text color
                    on_press: app.select_category('automata'); app.root.current = 'automata'


                Button:
                    text: ""
                    background_normal: 'formal_languages_icon.png'  # Formal Languages icon
                    size_hint: None, None
                    size: 200,200
                    on_press: app.select_category('formal_languages'); app.root.current = 'formal_languages'

                Button:
                    text: ""
                    background_normal: 'grammars_icon.png'  # Grammars icon
                    size_hint: None, None
                    size: 200,200
                    on_press: app.select_category('grammars'); app.root.current = 'grammars'

            Label:
                text: "Learning Portal"

                font_size: 28
                halign: 'center'
                valign: 'center'
                color: 1, 0, 0, 1
                size_hint_y: None
                height: 80

            Button:
                text: "Log out"
                size_hint: None, None
                size: 100, 50
                pos_hint: {'center_x': 0.5}
                on_press: app.root.current = 'login'
        
# Automata Lessons
<AutomataScreen>:
    BoxLayout:
        orientation: 'vertical'
        spacing: 20
        padding: 50
        color:0, 0, 0, 1
        canvas.before:
            Rectangle:
                source: "Backgroung.png"  
                pos: self.pos
                size: self.size
        Label:
            text: "Automata Lessons"
            font_size: 28
            color: 1, 0, 0, 1
            bold:True
        ScrollView:
            do_scroll_x: False
            BoxLayout:
                orientation: 'vertical'
                size_hint_y: None
                height: self.minimum_height

                Button:
                    text: "1. Introduction to Automata"
                    size_hint_y: None
                    height: 50
                    font_size: 18
                    on_press: 
                        app.set_automata_detail("Introduction to Automata","Formal Languages",'''  Introduction to Automata   \n \n Automata are mathematical models of computation that define formal systems for recognizing patterns and processing input. These models are used to study the behavior of machines and are foundational in fields like computer science, formal language theory, and the design of programming languages, compilers, and other computational systems. \n  Automata theory deals with the study of abstract machines (automata) and the problems they can solve. It explores how input symbols are processed by machines according to specific rules and what kinds of languages these machines can recognize. \n \n  Key Concepts of Automata Theory \n Automaton (Plural: Automata): \n An automaton is a theoretical machine that performs computations based on input symbols and follows a set of predefined rules. It consists of a finite number of states, a set of input symbols, and transition rules that determine how the machine moves between states. \n 1.States: \n States represent the different configurations of an automaton during its computation process.Each state defines a particular condition in which the machine can be at any given time. \n 2.Alphabet: \n An alphabet is a finite set of symbols used by the automaton to process input.\n \n  Example: Σ = {a, b}, where 'a' and 'b' are symbols. \n Transition Function: \n The transition function defines how the automaton moves between states based on the input symbols.  \n It specifies the next state given the current state and the input symbol.  \n Start State: \n The start state is the state where the automaton begins its computation process. \n 3. Accepting States:Accepting states (or final states) are the states where the automaton can halt and accept the input as valid or recognized by the machine. \n Input String:\n An input string is a sequence of symbols from the alphabet that the automaton processes. \n Output: \n The output of the automaton is the result of the computation, which could be an accepted/rejected status or a transformation of the input string. \n   Types of Automata   \n\n 1.Finite Automata (FA): \n A finite automaton is an abstract machine with a finite number of states. It is used to recognize regular languages. \n 2. Deterministic Finite Automaton (DFA): \n In a DFA, for each state and input symbol, there is exactly one transition. The machine is deterministic because the next state is uniquely determined by the current state and input symbol. \n 3.Non-deterministic Finite Automaton (NFA): In an NFA, there can be multiple transitions for the same input symbol from a given state, or even transitions without consuming any input (epsilon transitions). NFAs are non-deterministic because the next state is not uniquely determined. \n 4. Pushdown Automaton (PDA): \n A pushdown automaton is a more powerful machine that can use a stack to store symbols. It recognizes context-free languages, which are more complex than regular languages. PDAs are used to model grammars that require memory beyond a finite set of states, such as context-free grammars (CFG). \n 5. Turing Machine (TM): \n A Turing machine is a more powerful computational model that can simulate any algorithmic process. It consists of an infinite tape, a read/write head, and a finite set of states. It can process input, store intermediate results, and manipulate symbols on the tape according to a set of rules. Turing machines are capable of recognizing recursively enumerable languages, which are the most general class of languages. \n 6. Linear Bounded Automaton (LBA): A linear bounded automaton is a type of Turing machine that operates within a space bounded by the input size. It is used to recognize context-sensitive languages, which are more complex than context-free languages.Applications of Automata \n 7.  Text Processing and Pattern Matching: Automata, especially finite automata, are widely used for text searching and pattern matching tasks (e.g., in regular expressions). \n 8. ompiler Design: \n Automata play a crucial role in the design of compilers. They help in lexical analysis (tokenization) and parsing (syntax analysis), which are key stages in compiling programming languages. \n 9.Natural Language Processing (NLP): \n  Automata are used in various NLP tasks, such as parsing sentences, recognizing speech, and modeling syntax and grammar. \n 10. Network Protocols:  Finite automata are used in network protocols to describe the states of communication systems and ensure that data is transmitted correctly. \n 11. Control Systems and Robotics: \n Automata are used in the design of control systems, such as traffic lights, robots, and other automated systems, to manage different states and transitions based on inputs. Key Operations on Automata \n 11. Recognition: An automaton processes an input string and determines whether the string is accepted by the machine. If the automaton ends in an accepting state after processing the input, the string is considered recognized. \n 12.  Language Recognition: \n The set of strings that an automaton can accept forms a language. Automata are classified according to the types of languages they can recognize: DFAs and NFAs recognize regular languages. PDAs recognize context-free languages. Turing machines recognize recursively enumerable languages.''')
                
                Button:
                    text: "2. Deterministic Finite Automata (DFA)"
                    size_hint_y: None
                    height: 50
                    font_size: 18
                    on_press: 
                       #app.set_automata_detail("Deterministic Finite Automata (DFA)","DFA identification from labeled words",'''Given a set of positive words S+ ⊂ Σ* and a set of negative words S− ⊂ Σ*, one can construct a DFA that accepts all words from S+ and rejects all words from S−. This problem is called DFA identification (synthesis, learning). While some DFA can be constructed in linear time, the problem of identifying a DFA with the minimal number of states is NP-complete. The TB-algorithm:  The first algorithm for minimal DFA identification was proposed by Trakhtenbrot and Barzdin, called the TB-algorithm. However, this algorithm assumes that all words from Σ up to a given length are contained in either S+ ∪ S−. The Traxbar Algorithm:  Later, K. Lang proposed an extension of the TB-algorithm that does not make any assumptions about S+ and S−. The Traxbar algorithm does not guarantee the minimality of the constructed DFA. Gold's Heuristic Algorithm:  E.M. Gold proposed a heuristic algorithm for minimal DFA identification. Gold’s algorithm assumes that S+ and S− contain a characteristic set of the regular language. Otherwise, the constructed DFA will be inconsistent with either S+ or S−. Other Notable Algorithms:  - The RPNI algorithm.- The Blue-Fringe evidence-driven state-merging algorithm.- Windowed-EDSM. Evolutionary Algorithms:  Evolutionary algorithms have been applied to the DFA identification problem. The smart state labeling evolutionary algorithm addresses a modified DFA identification problem where training data (sets S+ and S−) are noisy, meaning some words may be attributed to the wrong classes. Application of SAT Solvers:  Marjin J. H. Heule and S. Verwer applied SAT solvers to the minimal DFA identification problem, reducing it to deciding the satisfiability of a Boolean formula. The key idea is to build an augmented prefix-tree acceptor (a trie containing all input words with corresponding labels) and reduce the problem of finding a DFA with C states to coloring the tree vertices with C states. Challenges:  Though this approach allows for finding the minimal DFA, it suffers from exponential blow-up of execution time when the size of input data increases. To address this, the DFASAT algorithm was introduced, which applies several steps of the EDSM algorithm prior to SAT solver execution to reduce the search space. However, this approach leads to a loss of the minimality guarantee. Symmetry Breaking Predicates:  Another reduction in search space was proposed by Ulyantsev et al., using new symmetry-breaking predicates based on breadth-first search (BFS) algorithms. This approach reduces the search space by C! by eliminating isomorphic automata.''')
                        app.set_automata_detail("DFA Identification from Labeled Words","Induction of Regular Languages", '''DFA identification from labeled words\n Main article: Induction of regular languages\n  \n Given a set of positive words S+ ⊂ Σ* and a set of negative words S- ⊂ Σ*, one can construct a DFA that accepts all words from S+ and rejects all words from S-. This problem is called DFA identification (synthesis, learning). While some DFA can be constructed in linear time, the problem of identifying a DFA with the minimal number of states is NP-complete.\n \n The first algorithm for minimal DFA identification has been proposed by Trakhtenbrot and Barzdin and is called the TB-algorithm. However, the TB-algorithm assumes that all words from Σ up to a given length are contained in either S+ ∪ S-.\n \n Later, K. Lang proposed an extension of the TB-algorithm that does not use any assumptions about S+ and S-, the Traxbar algorithm. However, Traxbar does not guarantee the minimality of the constructed DFA. In his work, E.M. Gold also proposed a heuristic algorithm for minimal DFA identification. Gold's algorithm assumes that S+ and S- contain a characteristic set of the regular language; otherwise, the constructed DFA will be inconsistent either with S+ or S-.\n \n Other notable DFA identification algorithms include the RPNI algorithm, the Blue-Fringe evidence-driven state-merging algorithm, and Windowed-EDSM. Another research direction is the application of evolutionary algorithms: the smart state labeling evolutionary algorithm allowed solving a modified DFA identification problem in which the training data (sets S+ and S-) is noisy in the sense that some words are attributed to wrong classes.\n \n Yet another step forward is due to the application of SAT solvers by Marjin J. H. Heule and S. Verwer: the minimal DFA identification problem is reduced to deciding the satisfiability of a Boolean formula. The main idea is to build an augmented prefix-tree acceptor (a trie containing all input words with corresponding labels) based on the input sets and reduce the problem of finding a DFA with C states to coloring the tree vertices with C states in such a way that when vertices with one color are merged to one state, the generated automaton is deterministic and complies with S+ and S-.\n \n Though this approach allows finding the minimal DFA, it suffers from exponential blow-up of execution time when the size of input data increases. Therefore, Heule and Verwer's initial algorithm has later been augmented with making several steps of the EDSM algorithm prior to SAT solver execution: the DFASAT algorithm. This allows reducing the search space of the problem but leads to loss of the minimality guarantee.\n \n Another way of reducing the search space has been proposed by Ulyantsev et al. by means of new symmetry-breaking predicates based on the breadth-first search algorithm: the sought DFA's states are constrained to be numbered according to the BFS algorithm launched from the initial state. This approach reduces the search space by C! by eliminating isomorphic automata. ''')

                Button:
                    text: "3. Nondeterministic Finite Automata (NFA)"
                    size_hint_y: None
                    height: 50
                    font_size: 18
                    on_press: 
                        app.set_automata_detail("Nondeterministic Finite Automata (NFA)","NFAs are...", '''An NFA is represented formally by a 5-tuple:  (Q, Σ, δ, q₀, F) , consisting of:1.  Q:  A finite set of states.2.  Σ:  A finite set of input symbols (alphabet).3.  δ:  A transition function δ: Q × Σ → P(Q), where δ maps a state and an input symbol to a set of possible next states.4.  q₀:  An initial (or start) state, q₀ ∈ Q. 5.  F:  A set of accepting (or final) states, F ⊆ Q.Here,  P(Q):  denotes the power set of Q, i.e., the set of all subsets of Q.  Recognized Language:  Given an NFA M = (Q, Σ, δ, q₀, F), its recognized language L(M) is defined as the set of all strings over the alphabet Σ that are accepted by M.Loosely corresponding to the above informal explanations, there are several equivalent formal definitions of a string w = a₁a₂...an being accepted by M:1.  w  is accepted if a sequence of states r₀, r₁, ..., rn exists in Q such that:- r₀ = q₀ (the machine starts in the start state).- ri+1 ∈ δ(ri, ai+1) for i = 0, ..., n-1 (the machine transitions from state to state based on input). - rn ∈ F (the machine ends in one of the accepting states).In words:- The first condition says that the machine starts in the start state q₀.- The second condition says that for each character in string w, the machine will transition according to δ.- The last condition says that the machine accepts w if the final input character causes the machine to halt in an accepting state.It is not necessary for every state sequence to end in an accepting state; it is sufficient if one does. If it is impossible to reach an accepting state from q₀ using the input string w, the automaton rejects the string. The set of strings M accepts is the language recognized by M, and this language is denoted by L(M).''')

                Button:
                    text: "4. Pushdown Automata (PDA)"
                    size_hint_y: None
                    height: 50
                    font_size: 18
                    on_press: 
                        app.set_automata_detail("Pushdown Automata (PDA)","PDAs extend...", '''  Acceptance by PDA:  \n A PDA accepts an input string by either  :1. Final State Acceptance: The input string is accepted if the PDA reaches a state in the accepting set F after reading the entire input string.   2. Empty Stack Acceptance: The input string is accepted if the PDA consumes the entire input string and the stack is empty at the end.In most cases, the PDA accepts a string if there exists a sequence of transitions that leads the automaton to an accepting state or empties the stack. Key Concepts in PDA: - Stack: The stack provides additional memory to the PDA, allowing it to store symbols while processing the input. This enables the PDA to recognize context-free languages, which cannot be recognized by finite automata alone.- Non-determinism: PDAs can be non-deterministic, meaning that for a given input symbol and stack symbol, the PDA can make multiple possible transitions. This allows PDAs to recognize a wider range of languages. <img src="../source/repos/MachineLearning/MobileApp/AutomataQuestion_image.png" alt="Pushdown Automaton Diagram" style="width: 50%; height: auto; margin: 20px 0;"/> Applications of PDA: 1.  Programming Language Parsing: PDAs are extensively used in compilers and interpreters for parsing context-free languages, such as the syntax of programming languages.2.  Context-Free Grammar Recognition: PDAs are ideal for recognizing context-free grammars, which are used to define the syntax of programming languages and other formal languages.3.  Mathematical Proofs: PDAs play a role in formal language theory and are used to prove properties of context-free languages. Limitations of PDA: While PDAs are powerful and can recognize context-free languages, they are not capable of recognizing context-sensitive languages. PDAs also have limitations in terms of non-determinism, as they cannot always simulate deterministic behavior with a simple stack structure. Comparison with Finite Automata: Unlike finite automata, which have no memory of past input, PDAs can store symbols in their stack, which allows them to recognize languages that finite automata cannot, such as nested structures \n (e.g., balanced parentheses). However, PDAs are still less powerful than Turing machines, which have unbounded memory and can recognize more complex languages. Example of PDA: Consider a PDA designed to accept the language of balanced parentheses: L = { w | w is a string of balanced parentheses }.''')

                Button:
                    text: "5. Turing Machines"
                    size_hint_y: None
                    height: 50
                    font_size: 18
                    on_press: 
                      # app.set_automata_detail("Turing Machines","Turing Machines are...",'''A Turing machine is a mathematical model of computation that defines an abstract machine.Despite its simplicity, it is capable of simulating any computer algorithm.''')
                        app.set_automata_detail("Introduction to Automata","Automata Theory",'''Automata theory is a branch of computer science that deals with the study of abstract machines (automata) and the problems they are capable of solving. It forms the foundation of theoretical computer science and has applications in designing compilers, parsing programming languages, and formal verification.\n\n Key Concepts in Automata:\n 1. Alphabet (Σ):\n - A finite set of symbols used to construct strings.\n - Example: Σ = {a, b, c}.\n\n 2. String:\n - A finite sequence of symbols from an alphabet.\n - Example: For Σ = {a, b}, strings include ab, baa, ε (empty string).\n\n 3. Language (L):\n - A set of strings formed from an alphabet.\n - Example: L = {a^n b^n | n ≥ 0} (equal number of a and b).\n\n 4. Automaton:\n - A mathematical model of computation used to recognize patterns or languages.\n\n Types of Automata:\n 1. Finite Automata:\n- Deterministic Finite Automata (DFA): Each state has exactly one transition for each input symbol.\n - Nondeterministic Finite Automata (NFA): Multiple transitions for the same input are allowed.\n\n 2. Pushdown Automata (PDA):\n - Uses a stack as additional memory and recognizes context-free languages.\n\n 3. Turing Machine:\n - A theoretical model of computation that can simulate any algorithm and recognizes recursively enumerable languages.\n\n 4. Linear Bounded Automata (LBA):\n  - A restricted form of Turing machine with bounded tape length and recognizes context-sensitive languages.\n\n Applications of Automata:\n1. Compiler Design:\n - Lexical analysis and syntax analysis use regular and context-free languages.\n\n 2. Text Processing:\n - Pattern matching using regular expressions.\n\n 3. Artificial Intelligence:\n - Formalizing behaviors in robotics and AI systems.\n\n 4. Networking:\n - Protocol verification in network systems.\n\n 5. Game Theory:\n - Modeling state-based systems in games.\n\n Why Study Automata?\n Understanding automata helps in designing efficient algorithms for pattern recognition, developing theoretical foundations for computer science, and modeling and verifying systems in engineering and software design''')

        BoxLayout:
            size_hint_y: None
            height: 60
            spacing: 750

            Button:
                text: ""
                background_normal: 'back_arrow.png' 
                size_hint: None, None
                size: 90, 70
                on_press: app.root.current = 'home'
            Button:
                text: ""
                background_normal: 'practice_icon.png'  
                size_hint: None, None
                size: 90, 70
                on_press: app.root.current = 'automata_practice'
                 
# Practice Screen
<AutomataPracticeScreen>:
    BoxLayout:
        orientation: 'vertical'
        spacing: 20
        padding: 50
        canvas.before:
            Rectangle:
                source: "Backgroung.png"
                pos: self.pos
                size: self.size

        Label:
            id: question_label
            text: "Question will appear here."
            font_size: 20
            halign: 'center'
            color: 0, 0, 0, 1

        ScrollView:
            do_scroll_x: False
            BoxLayout:
                orientation: 'vertical'
                size_hint_y: None
                height: self.minimum_height
                Button:
                    id: option_a
                    text: "Option A"
                    size_hint_y: None
                    height: 40
                    on_press: app.check_answer('A')
                Button:
                    id: option_b
                    text: "Option B"
                    size_hint_y: None
                    height: 40
                    on_press: app.check_answer('B')
                Button:
                    id: option_c
                    text: "Option C"
                    size_hint_y: None
                    height: 40
                    on_press: app.check_answer('C')
                Button:
                    id: option_d
                    text: "Option D"
                    size_hint_y: None
                    height: 40
                    on_press: app.check_answer('D')

        Button:
            text: ""
            background_normal: 'lessonsImages/refreshicon.png'
            size_hint: None, None
            size: 90, 90
            on_press: app.refresh_screen('automata')

<AutomataDetailScreen>:
    BoxLayout:
        orientation: 'vertical'
        spacing: 20
        padding: [30, 20, 30, 20]  # Left, Top, Right, Bottom padding

        canvas.before:
            Rectangle:
                source: "Background.png"  
                pos: self.pos
                size: self.size

        # Title Section
        Label:
            id: heading_label  # Updated ID
            text: "Automata Topic"
            font_size: 24
            bold: True
            color: 0, 0, 0, 1
            halign: "center"
            valign: "middle"
            size_hint_y: None
            height: 40

        # Paragraph Section
        Label:
            id: paragraph_heading  # Added ID for paragraph heading
            text: "Paragraph Heading"
            font_size: 20
            bold: True
            color: 0, 0, 0, 1
            halign: "center"
            valign: "middle"
            size_hint_y: None
            height: 30

        # Content Section with ScrollView
        ScrollView:
            do_scroll_x: False
            do_scroll_y: True
            bar_width: 10
            bar_color: [0.2, 0.6, 0.8, 0.8]  # Light blue scroll bar color
            BoxLayout:
                orientation: 'vertical'
                size_hint_y: None
                height: self.minimum_height
                padding: 10
                spacing: 10

                Label:
                    id: content_label  # Updated ID
                    text: "Detailed explanation of the topic will appear here."
                    font_size: 18
                    halign: "justify"
                    valign: "top"
                    size_hint_y: None
                    text_size: self.width, None  # Adjust text width to box
                    height: self.texture_size[1]
                    color: 0, 0, 0, 1

        # Navigation Button Section
        BoxLayout:
            size_hint_y: None
            height: 60
            padding: [0, 10, 0, 10]  # Padding for better alignment
            spacing: 20

            Button:
                text: ""
                background_normal: 'back_arrow.png' 
                size_hint: None, None
                size: 90, 70
                on_press: app.root.current = 'automata'

<FormalDetailScreen>:
    BoxLayout:
        orientation: 'vertical'
        spacing: 20
        padding: [30, 20, 30, 20]  # Left, Top, Right, Bottom padding

        canvas.before:
            Rectangle:
                source: "Background.png"  
                pos: self.pos
                size: self.size

        # Title Section
        Label:
            id: heading_label  # Updated ID
            text: "Formal Languages Topic"
            font_size: 24
            bold: True
            color: 0, 0, 0, 1
            halign: "center"
            valign: "middle"
            size_hint_y: None
            height: 40

        # Paragraph Section
        Label:
            id: paragraph_heading  # Added ID for paragraph heading
            text: "Paragraph Heading"
            font_size: 20
            bold: True
            color: 0, 0, 0, 1
            halign: "center"
            valign: "middle"
            size_hint_y: None
            height: 30

        # Content Section with ScrollView
        ScrollView:
            do_scroll_x: False
            do_scroll_y: True
            bar_width: 10
            bar_color: [0.2, 0.6, 0.8, 0.8]  # Light blue scroll bar color
            BoxLayout:
                orientation: 'vertical'
                size_hint_y: None
                height: self.minimum_height
                padding: 10
                spacing: 10

                Label:
                    id: content_label  # Updated ID
                    text: "Detailed explanation of the topic will appear here."
                    font_size: 18
                    halign: "justify"
                    valign: "top"
                    size_hint_y: None
                    text_size: self.width, None  # Adjust text width to box
                    height: self.texture_size[1]
                    color: 0, 0, 0, 1

        # Navigation Button Section
        BoxLayout:
            size_hint_y: None
            height: 60
            padding: [0, 10, 0, 10]  # Padding for better alignment
            spacing: 20

            Button:
                text: ""
                background_normal: 'back_arrow.png' 
                size_hint: None, None
                size: 90, 70
                on_press: app.root.current = 'formal_languages'


<GrammarsDetailScreen>:

    BoxLayout:
        orientation: 'vertical'
        spacing: 20
        padding: [30, 20, 30, 20]  # Left, Top, Right, Bottom padding

        canvas.before:
            Rectangle:
                source: "Background.png"  
                pos: self.pos
                size: self.size

        # Title Section
        Label:
            id: heading_label  # Updated ID
            text: "Grammars Topic"
            font_size: 24
            bold: True
            color: 0, 0, 0, 1
            halign: "center"
            valign: "middle"
            size_hint_y: None
            height: 40

        # Paragraph Section
        Label:
            id: paragraph_heading  # Added ID for paragraph heading
            text: "Paragraph Heading"
            font_size: 20
            bold: True
            color: 0, 0, 0, 1
            halign: "center"
            valign: "middle"
            size_hint_y: None
            height: 30

        # Content Section with ScrollView
        ScrollView:
            do_scroll_x: False
            do_scroll_y: True
            bar_width: 10
            bar_color: [0.2, 0.6, 0.8, 0.8]  # Light blue scroll bar color
            BoxLayout:
                orientation: 'vertical'
                size_hint_y: None
                height: self.minimum_height
                padding: 10
                spacing: 10

                Label:
                    id: content_label  # Updated ID
                    text: "Detailed explanation of the topic will appear here."
                    font_size: 18
                    halign: "justify"
                    valign: "top"
                    size_hint_y: None
                    text_size: self.width, None  # Adjust text width to box
                    height: self.texture_size[1]
                    color: 0, 0, 0, 1

        # Navigation Button Section
        BoxLayout:
            size_hint_y: None
            height: 60
            padding: [0, 10, 0, 10]  # Padding for better alignment
            spacing: 20

            Button:
                text: ""
                background_normal: 'back_arrow.png' 
                size_hint: None, None
                size: 90, 70
                on_press: app.root.current = 'grammars'

   
# Formal Languages Lessons
<FormalLanguagesScreen>:
    BoxLayout:
        orientation: 'vertical'
        spacing: 20
        padding: 50
        color:0, 0, 0, 1
        canvas.before:
            Rectangle:
                source: "Backgroung.png"  
                pos: self.pos
                size: self.size
        Label:
            text: "Formal Languages Lessons"
            font_size: 28
            color: 1, 0, 0, 1
            bold:True
        ScrollView:
            do_scroll_x: False
            BoxLayout:
                orientation: 'vertical'
                size_hint_y: None
                height: self.minimum_height
                Button:
                    text: "1. Chapter 1"
                    size_hint_y: None
                    height: 40
                    on_press: app.set_formal_detail("Formal Languages", "Chomsky’s Formal Grammar", ''' In computer science, a formal language is a set of strings of symbols that may be constrained by rules specific to it, while formal grammar is a method to depict the set. \n\nThe reason for naming formal grammar is that it is similar to the grammar in natural language. Chomsky’s classification of grammars in 1950 divides grammar into four categories: phrase structure grammar, context-sensitive grammars, context-free grammars (CFGs), and regular grammars. Any language can be expressed by unrestricted grammar, while the remaining three categories—enumerate language, context-free language (CFL), and formal language—are represented by context-free grammar and regular grammar. Despite weaker expressive power compared to phrase structure grammar and context-sensitive grammar, CFGs and regular grammars are the most important types of grammar in computer science.\n\n 6.4.1 Phrase Structure Grammar: \n\nPhrase structure grammar is a type of non-restricted grammar, also known as 0-type grammar, and is an essential concept in formal language theory. It is represented by a four-tuple G = (Σ, V, S, P), where Σ is the terminal alphabet, V is the nonterminal alphabet, S is the start symbol, and P is a set of production rules. These rules are defined as α→β, where α and β are sequences of symbols from Σ and V. There are no restrictions on α and β in phrase structure grammar, which is why it is also referred to as unrestricted grammar. The language generated by 0-type grammar is equivalent to the recursive enumerable language (LRE) that a Turing machine accepts.\n\nFor example, consider G = ({a}, {[,], A, D, S}, S, P), where P = {S→[A], [→[D, D]→], DA→AAD, [→∧, ]→∧, A→a}. This is a phrase structure grammar that generates a 0-type language L(G) = {a^(2n) | n ≥ 0}. The standard forms of production rules in phrase structure grammar include A→ξ, A→BC, A→∧, and AB→CD, which generate languages that can be processed by Turing machines.\n\n 6.4.2 Context-sensitive Grammar: \n\nContext-sensitive grammar is an important grammar type in formal language theory, where the left-hand and right-hand sides of production rules may be surrounded by terminal and non-terminal symbols. A formal grammar G = (Σ, V, S, P), where Σ is a set of terminal symbols and V is a set of nonterminal symbols, is context-sensitive if production rules are in the form of αAβ→αγβ, where A is a non-terminal, and α, β, and γ are sequences of terminal and non-terminal symbols. Context-sensitive grammar is also called 1-type grammar, indicating that A can be replaced by γ in the context of α on the left and β on the right.\n\nMonotonous grammar is a specific type of context-sensitive grammar where production rules take the form α→β, with |α| ≤ |β|. A grammar G = ({a, b, c}, {S, A, B}, S, P), where P = {S→aSAB/aAB, BA→AB, aA→ab, bA→bb, bB→bc, CB→cc}, is an example of monotonous grammar, which also functions as context-sensitive grammar. This grammar generates the context-sensitive language L(G) = {a^n b^n c^n | n ≥ 1}. The language class generated by monoton''')

                Button:
                    text: "2. Languages"
                    size_hint_y: None
                    height: 40
                    on_press: app.set_formal_detail("Languages","We have got acquainted with the formal notion of strings that are basic elements of a language. ", ''' Example 2.2.1. 1.\n\n The  emptyset ∅ is a language over any alphabet. Similarly, {ε} is also a language over any alphabet. \n 2. The set of all strings over {0, 1} that start with 0. \n 3. The set of all strings over {a, b, c} having ac as a substring. Remark 2.2.2. Note that ∅ /= {ε}, because the language ∅ does not contain any string but {ε} contains a string, namely ε. Also it is evident that |∅| = 0; whereas, |{ε}| = 1. Since languages are sets, we can apply various well known set operations such as union, intersection, complement, difference on languages. The notion of concatenation of strings can be extended to languages as follows. The concatenation of a pair of languages L1, L2 is   1L2 = {xy | x ∈ L1 ∧ y ∈ L2}.   \n Example 2.2.3. 1. If L1 = {0, 1, 01} and L2 = {1, 00}, then L1L2 = {01, 11, 011, 000, 100, 0100}. \n 2. For L1 = {b, ba, bab} and L2 = {ε, b, bb, abb}, we have L1L2 = {b, ba, bb, bab, bbb, babb, baabb, babbb, bababb}. Remark 2.2.4. 1. Since concatenation of strings is associative, so is the concatenation of languages. That is, for all languages L1, L2 and L3, (L1L2)L3 = L1(L2L3). Hence, (L1L2)L3 may simply be written as L1L2L3. 2. The number of strings in L1L2 is always less than or equal to the product of individual numbers, i.e. |L1L2| ≤ |L1||L2|.\n 3. L1 ⊆ L1L2 if and only if ε ∈ L2. Proof. The “if part” is straightforward; for instance, if ε ∈ L2, then for any x ∈ L1, we have x = xε ∈ L1L2. On the other hand, suppose ε ∈/ L2. Now, note that a string x ∈ L1 of shortest length in L1 cannot be in L1L2. This is because, if x = yz for some y ∈ L1 and a nonempty string z ∈ L2, then |y| < |x|. A contradiction to our assumption that x is of shortest length in L1. Hence L1 /⊆ L1L2. 4. Similarly, ε ∈ L1 if and only if L2 ⊆ L1L2. We write Ln to denote the language which is obtained by concatenating n copies of L. More formally, L0 = {ε} and Ln = Ln−1L, for n ≥ 1.In the context of formal languages, another important operation is Kleene star. Kleene star or Kleene closure of a language L, denoted by L∗, is defined as L∗ = L n. n≥0 ''')

                Button:
                    text: "3. Finite Representation"
                    size_hint_y: None
                    height: 40
                    #on_press: app.set_formal_detail("Finite Representation","Regular Expressions.",'''We now consider the class of languages obtained by applying union, con- catenation, and Kleene star for finitely many times on the basis elements. These languages are known as regular languages and the corresponding finite representations are known as regular expressions. Definition 2.4.1 (Regular Expression). We define a regular expression over an alphabet Σ recursively as follows. 1.	∅, ε, and a, for each a ∈ Σ, are regular expressions representing the languages ∅, {ε}, and {a}, respectively. 2.	If r and s are regular expressions representing the languages R and S, respectively, then so are (a)	(r + s) representing the language R ∪ S, (b)	(rs) representing the language RS, and (c)	(r∗) representing the language R∗. In a regular expression we keep a minimum number of parenthesis which are required to avoid ambiguity in the expression. For example, we may simply write r + st in case of (r + (st)). Similarly, r + s + t for ((r + s) + t).''')
                    on_press: app.set_automata_detail("Finite Automaton Representation", "Finite Automaton (FA) Overview", "1.   Definition of Finite Automaton   A Finite Automaton is represented as a 5-tuple, often written as: (Q, Σ, δ, q₀, F) Where: **Q:** A finite set of states, where each state represents a unique condition or configuration of the automaton. **Σ (Sigma):** A finite set of input symbols known as the alphabet. These symbols represent the possible characters that the automaton can process. **δ (Delta):\n A transition function that defines the rules for transitioning from one state to another based on the input symbol. Mathematically, this is defined as δ: Q × Σ → Q for Deterministic Finite Automata (DFA), or δ: Q × Σ → P(Q) for Nondeterministic Finite Automata (NFA), where P(Q) represents a set of states.   q₀:   The initial state where the automaton begins its operation. \n This is an element of Q. **F:** A set of accepting (final) states, which are the states that signify the automaton has successfully accepted an input string. This is a subset of Q. 2. **Components of a Finite Automaton** - **States (Q):** The finite set of states represents the 'memory' of the automaton. Each state represents a unique situation during the processing of an input string. - **Alphabet (Σ):** The alphabet Σ consists of a finite set of symbols that the automaton can read. Example: Σ = {0, 1} for a DFA designed to recognize binary strings. - **Transition Function (δ):** The transition function determines how the automaton moves from one state to another. For a DFA: δ(q, a) → q′ (there is exactly one transition for every state and input symbol pair). For an NFA: δ(q, a) → P(Q) (the transition can be to a set of states, allowing multiple transitions for the same state and input symbol). - **Initial State (q₀):** This is the state where the automaton starts processing an input string. - **Accepting States (F):** These are the states in which, if the automaton finishes processing the entire input string, the string is accepted. 3. **Deterministic vs Nondeterministic Finite Automaton** - **Deterministic Finite Automaton (DFA):** In a DFA, for every state and input symbol, there is exactly one possible transition to another state. The computation is deterministic. Mathematically: δ: Q × Σ → Q. - **Nondeterministic Finite Automaton (NFA):** In an NFA, for a given state and input symbol, there can be multiple possible transitions (or even none). The automaton can be in multiple states at once. Mathematically: δ: Q × Σ → P(Q), where P(Q) is the power set of Q, representing the set of possible states. 4. **Processing a String** The automaton processes an input string by reading the symbols one by one. For each symbol, the automaton transitions from one state to another according to the transition function. Once all symbols in the string are processed, if the automaton ends in an accepting state, the string is accepted; otherwise, it is rejected. 5. **Acceptance Criteria** - **DFA:** A string is accepted if, starting from the initial state q₀, the automaton processes the entire string and ends in an accepting state. - **NFA:** A string is accepted if there is some sequence of transitions that leads to an accepting state after processing the entire string. 6. **Power Set Construction for NFA to DFA** An NFA can be converted to an equivalent DFA using the Power Set Construction method. This method constructs a DFA where each state represents a set of NFA states, effectively eliminating the nondeterminism of the NFA. 7. **Example** Consider an example where an NFA recognizes binary strings that contain an even number of 0s. - **States (Q):** {q₀, q₁} - **Alphabet (Σ):** {0, 1} - **Transition Function (δ):** δ(q₀, 0) = q₁, δ(q₀, 1) = q₀, δ(q₁, 0) = q₀, δ(q₁, 1) = q₁ - **Initial State (q₀):** q₀ - **Accepting States (F):** {q₀} (because the string is accepted if it ends in an even number of 0s) This NFA can be represented as: Q = {q₀, q₁}, Σ = {0, 1}, δ, q₀, F = {q₀} The string 1010 would be processed as follows: - Start at q₀. - Read 1, stay at q₀. - Read 0, transition to q₁. - Read 1, stay at q₁. - Read 0, transition to q₀. Since the automaton ends in the accepting state q₀, the string is accepted.")

                Button:
                    text: "4. Types of Grammars"
                    size_hint_y: None
                    height: 40
                    #on_press: app.set_formal_detail("Introduction to Formal Languages","Formal Languages are mathematical models ...",'''A language can be seen as a system suitable for expression of certain ideas, facts, and concepts.For formalizing the notion of a language, one must cover all varieties of languages, such as natural (human) languages and programming languages. Let us look at some common features across the languages. One may broadly see that a language is a collection of sentences;a sentence is a sequence of words; and a word is a combination of syllables. If one considers a language that has a script, then it can be observed that a word is a sequence of symbols of its underlying alphabet. It is observed that a formal learning of a language has the following three steps.''')
                    on_press: app.set_automata_detail("Introduction to Formal Languages", "Understanding Formal Languages", "\n Formal languages\n  are mathematical models used to define the syntax and structure of languages. They are essential for understanding computer science, linguistics, and automata theory.\n\n\n Key Concepts in Formal Languages:\n  1. \n Alphabet (Σ):\n  A finite set of symbols used to construct strings. Example: Σ = {a, b, c}.\n\n2. \n String:\n  A finite sequence of symbols from an alphabet. Example: For Σ = {a, b}, strings include ab, baa, ε (empty string).\n\n3. \n Language (L):\n  A set of strings formed from an alphabet. Example: L = {a^n b^n | n ≥ 0} (equal number of a and b).\n\n\n Types of Formal Languages:\n  1. \n Regular Languages:\n  Recognized by finite automata. Example: L = {w | w contains an even number of 0s}.\n\n2. \n Context-Free Languages:\n  Recognized by pushdown automata. Example: L = {w | w is a string of balanced parentheses}.\n\n3. \n Context-Sensitive Languages:\n  Recognized by linear bounded automata. Example: L = {a^n b^n c^n | n ≥ 1}.\n\n4. \n Recursively Enumerable Languages:\n  Recognized by Turing machines. Example: L = {w | w encodes a valid computation}.\n\n\n Applications of Formal Languages:\n  1. \n Programming Language Design:\n  Defining syntax rules using context-free grammars. 2. \n Compiler Construction:\n  Parsing and translating programming code. 3. \n Natural Language Processing: \n  Modeling and understanding human languages. 4. \n Automata Theory:\n  Designing models for computational problems.\n\n\n Why Study Formal Languages?\n  Formal languages provide the theoretical foundation for understanding computation, developing efficient algorithms, and modeling real-world systems in engineering, linguistics, and artificial intelligence.")

        BoxLayout:
            size_hint_y: None
            height: 60
            spacing: 750
            Button:
                text: ""
                background_normal: 'back_arrow.png' 
                size_hint: None, None
                size: 90, 70
                on_press: app.root.current = 'home'
            Button:
                text: ""
                background_normal: 'practice_icon.png'  
                size_hint: None, None
                size: 70, 70
                on_press: app.root.current = 'formalpraticescreen'

<FormalPracticeScreen>:
    BoxLayout:
        orientation: 'vertical'
        spacing: 20
        padding: 50
        canvas.before:
            Rectangle:
                source: "Backgroung.png"
                pos: self.pos
                size: self.size

        Label:
            id: question_label
            text: "Question will appear here."
            font_size: 20
            halign: 'center'
            color: 0, 0, 0, 1
        ScrollView:
            do_scroll_x: False
            BoxLayout:
                orientation: 'vertical'
                size_hint_y: None
                height: self.minimum_height
                Button:
                    id: option_a
                    text: "Option A"
                    size_hint_y: None
                    height: 40
                    on_press: app.check_answer('A')
                Button:
                    id: option_b
                    text: "Option B"
                    size_hint_y: None
                    height: 40
                    on_press: app.check_answer('B')
                Button:
                    id: option_c
                    text: "Option C"
                    size_hint_y: None
                    height: 40
                    on_press: app.check_answer('C')
                Button:
                    id: option_d
                    text: "Option D"
                    size_hint_y: None
                    height: 40
                    on_press: app.check_answer('D',)
        Button:
            text: ""
            background_normal: 'lessonsImages/refreshicon.png'
            size_hint: None, None
            size: 90, 90
            on_press: app.refresh_screen('formal_languages')

# Grammars Lessons
<GrammarsScreen>:
    BoxLayout:
        orientation: 'vertical'
        spacing: 20
        padding: 40
        canvas.before:
            Rectangle:
                source: "Backgroung.png"  
                pos: self.pos
                size: self.size
        Label:
            text: "Grammars Lessons"
            font_size: 28
            color: 1, 0, 0, 1
            bold:True
        ScrollView:
            do_scroll_x: False
            BoxLayout:
                orientation: 'vertical'
                size_hint_y: None
                height: self.minimum_height
                Button:
                    text: "1. Introduction to Grammars"
                    size_hint_y: None
                    height: 40
                    #on_press: app.set_gramma_detail("Grammars","context-free gram- mar",'''In this chapter, we introduce the notion of grammar called context-free gram- mar (CFG) as a language generator. The notion of derivation is instrumental in understanding how the strings are generated in a grammar. We explain the various properties of derivations using a graphical representation called derivation trees. A special case of CFG, viz. regular grammar, is discussed as tool to generate to regular languages. A more general notion of grammars is presented in Chapter 7. In the context of natural languages, the grammar of a language is a set of rules which are used to construct/validate sentences of the language. It has been pointed out, in the introduction of Chapter 2, that this is the third step in a formal learning of a language. Now we draw the attention of a reader to look into the general features of the grammars (of natural languages) to formalize the notion in the present context which facilitate for better under- standing of formal languages. Consider the English sentence. In this process, we observe that two types of words are in the discussion. 1.	The words like the, study, students. 2.	The words like Article, Noun, Verb. The main difference is, if you arrive at a stage where type (1) words are appearing, then you need not say anything more about them. In case you arrive at a stage where you find a word of type (2), then you are assumed to say some more about the word. For example, if the word Article comes, then one should say which article need to be chosen among a, an and the. Let us call the type (1) and type (2) words as terminals and nonterminals, respectively, as per their features. Thus, a grammar should include terminals and nonterminals along with a set of rules which attribute some information regarding nonterminal symbols ''')
                    on_press: app.set_gramma_detail("Grammars","context-free gram- mar",'''\n Key Concepts in Formal Languages:\n  \n 1. Alphabet (Σ):\n  - A finite set of symbols used to construct strings. - Example: Σ = {a, b, c}. \n 2. String:\n  - A finite sequence of symbols from an alphabet. - Example: For Σ = {a, b}, strings include ab, baa, ε (empty string). \n 3. Language (L):\n  - A set of strings formed from an alphabet. - Example: L = {a^n b^n | n ≥ 0} (equal number of a and b). \n Types of Formal Languages:\n  \n 1. Regular Languages:\n  - Recognized by finite automata. - Example: L = {w | w contains an even number of 0s}. \n 2. Context-Free Languages:\n  - Recognized by pushdown automata. - Example: L = {w | w is a string of balanced parentheses}. \n 3. Context-Sensitive Languages:\n  - Recognized by linear bounded automata. - Example: L = {a^n b^n c^n | n ≥ 1}. \n 4. Recursively Enumerable Languages:\n  - Recognized by Turing machines. - Example: L = {w | w encodes a valid computation}. \n Applications of Formal Languages:\n  \n 1. Programming Language Design:\n  - Defining syntax rules using context-free grammars. \n 2. Compiler Construction:\n  - Parsing and translating programming code. \n 3. Natural Language Processing:\n  - Modeling and understanding human languages. \n 4. Automata Theory:\n  - Designing models for computational problems. \n Why Study Formal Languages?\n where you find a word of type (2), then you are assumed to say some more about the word. For example, if the word Article comes, then one should say which article need to be chosen among a, an and the. Let us call the type (1) and type (2) words as terminals and nonterminals, respectively, as per their features. Thus, a grammar should include terminals and nonterminals along with a set of rules which attribute some information regarding nonterminal symbols ''')
                Button:
                    text: "2. Derivation Trees"
                    size_hint_y: None
                    height: 40
                    on_press: app.set_gramma_detail("Derivation Trees","S → S ∗ S | S + S | (S) | a | b",'''Derivation Trees in Formal Languages \n\n A derivation tree (also known as a parse tree) is a tree representation of the syntactic structure of a string according to a grammar. It is used to represent how a string can be derived from a formal grammar using the production rules.Key Concepts of Derivation Trees \n 1. Root Node: The root of the tree represents the start symbol of the grammar. \n 2. Leaf Nodes: These represent the terminal symbols of the string being derived. In the \n 3.derivation tree, the leaves are the actual symbols of the string. \n 4.Intermediate Nodes: These nodes represent non-terminal symbols and are used in the production rules to derive the string. \n\n Edges: The edges between nodes represent the application of a production rule that rewrites one symbol into other symbols (either terminal or non-terminal). \n   Production Rules:   These are the rules from the grammar used to rewrite non-terminal symbols into terminal or other non-terminal symbols. \n\nStructure of a Derivation Tree \n 1. Start Symbol: The tree always starts from the start symbol of the grammar, which is the root node. \n 2.Branching: From any non-terminal node, the tree branches out according to the corresponding production rule. If the non-terminal symbol can be rewritten to other non-terminal symbols, those are further expanded into the next level. \n 3. Leaf Nodes: These are the terminal symbols, which do not branch further. The leaves represent the final string generated from the grammar. ''')
                Button:
                    text: "3. Ambiguity"
                    size_hint_y: None
                    height: 40
                    on_press: app.set_gramma_detail("Ambiguity","Ambiguity",'''Ambiguity in Formal Languages \n\nAmbiguity refers to the situation in which a grammar can generate the same string in more than one way. In other words, a grammar is ambiguous if there is more than one valid derivation or parse tree for a given string. This is a significant issue in formal language theory, especially in programming language design, where unambiguous grammars are highly desirable for clarity and consistency.Key Concepts of Ambiguity: \n 1.Ambiguous Grammar: A grammar is said to be ambiguous if there exists at least one string in the language generated by the grammar for which there are multiple derivation trees or parse trees. This can lead to confusion, as the structure of the string can be interpreted in multiple ways. \n  2.Unambiguous Grammar: A grammar is unambiguous if for every string in the language, there is exactly one derivation tree (or parse tree). Unambiguous grammars are preferred in most applications because they provide clear, predictable parsing behavior. \n 3. Derivation Tree Ambiguity: If a grammar can generate a string through multiple different sequences of applications of the production rules, it leads to multiple valid derivation trees for that string. This is a clear indication of ambiguity in the grammar. \n 4.Parse Tree Ambiguity: A parse tree is a visual representation of the structure of a string according to a grammar. If a grammar can generate more than one valid parse tree for the same string, it is considered ambiguous. Examples of Ambiguity: \n \n Consider the following grammar for arithmetic expressions:mathematica Copy code   E -> E + E | E * E | (E) | id   Using this grammar, we can derive the string id + id * id in two different ways:   (E + E) * id (parse it as id + (id * id))  \n E + (E * E) (parse it as (id + id) * id)   Both of these are valid derivations of the same string, which shows that the grammar is ambiguous. \n 5. Sources of Ambiguity: Operator Precedence: Ambiguities can arise when the grammar does not explicitly define the precedence of operators, as seen in the above example. Context Sensitivity: Ambiguities can also occur in grammars that do not take context into account properly, leading to multiple interpretations of a string. Recursion: Recursive rules can lead to ambiguity when the same non-terminal can be derived in different ways. \n 6. Resolving Ambiguity: Explicit Precedence and Associativity Rules: Ambiguity in arithmetic expressions, for example, can be resolved by introducing explicit precedence and associativity rules in the grammar, such as:  E -> E + T | T \n T -> T * F | F \n  F -> (E) | id   This eliminates the ambiguity by giving clear precedence to multiplication over addition. Grammar Transformation: In some cases, it may be possible to transform an ambiguous grammar into an unambiguous one by reworking the rules or restructuring the grammar. Context-Free Grammar with Clear Semantics: Some ambiguities can be resolved by providing additional semantic rules that guide the interpretation of ambiguous structures. \n \n Importance of Eliminating Ambiguity: \n Predictable Parsing: Ambiguity can make it difficult to build reliable parsers because the same string could be interpreted in multiple ways. Eliminating ambiguity ensures that parsers can always produce a unique parse tree for any input string. Compiler Design: In programming languages, ambiguity can lead to multiple interpretations of the same code, which is undesirable. Unambiguous grammars are crucial for compiler design to ensure correct translation of source code to machine code. Mathematical Consistency: In formal language theory, ambiguous grammars can lead to inconsistent interpretations of strings, which can undermine the theoretical foundations of the language. \n \n Conclusion: \n Ambiguity is a critical concept in formal languages and grammar design. While certain types of ambiguity may be acceptable in natural language processing, in formal languages (like programming languages), ambiguity must be avoided to ensure clarity, correctness, and consistency. A well-designed, unambiguous grammar leads to reliable parsing and avoids confusion''')
                Button:
                    text: "4. Regular Grammars"
                    size_hint_y: None
                    height: 40
                    on_press: app.set_gramma_detail("Regular Grammars","CFG G = (N, Σ, P, S) ",'''Regular Grammars: Detailed Information \n \nRegular grammars are a type of formal grammar used to describe regular languages. Regular languages are a class of languages that can be recognized by finite automata (FAs) and can be described by regular expressions. These grammars play a crucial role in formal language theory, compiler construction, and the design of search engines and text processing tools. \nDefinition: \n A regular grammar is a formal grammar that generates a regular language. It consists of a set of production rules used to generate strings in the language. Regular grammars have specific structural properties that distinguish them from other types of grammars. \n Types of Regular Grammars: \n There are two types of regular grammars: \n 1. Right-Regular Grammar (or Right-Linear Grammar): In a right-regular grammar, the production rules have the following form: \n A → xB or A → x where: \n A and B are non-terminal symbols. \n x is a terminal symbol (from the alphabet). \n A → x means the production can end with a terminal symbol. \n The non-terminal (if any) appears on the right side of the production. \n \n Example: \n S → aA \n A → b \n This grammar generates the string "ab." \n 2. Left-Regular Grammar (or Left-Linear Grammar): In a left-regular grammar, the production rules have the following form: \n A → Bx or A → x where: \n A and B are non-terminal symbols. \n x is a terminal symbol. \n A → x means the production can end with a terminal symbol. \n The non-terminal (if any) appears on the left side of the production. \n Example: \n S → Aa \n A → b \n This grammar generates the string "ba." \n 1. Properties of Regular Grammars: \n \n Non-deterministic finite automata (NFA) and deterministic finite automata (DFA) can recognize regular languages, and regular grammars can be converted into these automata.Closure Properties: Regular languages are closed under the operations of union, intersection, difference, concatenation, and Kleene star. \nFinite Representation: Regular grammars are efficient in representing languages with a finite set of rules, and they can describe simpler languages compared to context-free or context-sensitive grammars. \n 2. Chomsky Hierarchy and Regular Grammars: \n Regular grammars are the simplest type of grammar in the Chomsky hierarchy, which classifies grammars based on their generative power. The Chomsky hierarchy consists of: \nType 0: Recursively enumerable grammars (Turing machines) \n Type 1: Context-sensitive grammars \n Type 2: Context-free grammars \n Type 3: Regular grammars (the most restricted type) \n Regular Language Examples: \n Finite Languages: A language that contains a finite number of strings is a regular language. For example: \n L = {a, b, c} This language can be represented by the regular grammar: \n \n Strings with Specific Patterns: A regular grammar can describe strings that match certain patterns. For instance, a language that contains strings of "a"s followed by "b"s can be represented by: L = {ab, aab, aaab, ...} Regular grammar: \n \n Languages of the Form a^n b^n: The language of strings with equal numbers of "a"s followed by "b"s (such as "ab", "aabb", etc.) is not regular. This is because no finite automaton can recognize this pattern, and it requires a more powerful grammar (context-free grammar). \n Applications of Regular Grammars: \n Lexical Analysis: Regular grammars are used to define tokens (such as keywords, identifiers, and symbols) in programming languages. Lexical analyzers (lexers) use regular grammars to break input code into meaningful components. \n Pattern Matching and Search Engines: Regular expressions, which are based on regular grammars, are widely used for searching and matching patterns in text, such as finding email addresses or phone numbers. \n Text Processing: Tools like grep or sed for text processing and manipulation are built on regular grammars. \n Compiler Design: Regular grammars help in tokenizing the source code in the early stages of the compilation process. \n Conversion Between Regular Grammars and Finite Automata: \n \n From Regular Grammar to Finite Automaton: A regular grammar can be converted into a finite automaton (both DFA and NFA). From Finite Automaton to Regular Grammar: Any finite automaton can be converted into a regular grammar. \n Example: \n Consider the regular grammar for recognizing the language of strings consisting of the letter "a" followed by the letter "b": \n \n Regular grammar: \n This generates the string "ab." This can be converted into a finite automaton: States: S (start), A (final) Transitions: S → a → A, A → b (accepts "ab") Key Points to Remember: \n Regular grammars are very restricted and generate regular languages, which can be recognized by finite automata. \n They can describe simple languages and patterns but cannot handle languages that require memory, such as balanced parentheses or strings with equal numbers of two symbols. Regular grammars are useful in practical applications like regular expressions, text processing, and lexical analysis. \n By understanding regular grammars, you gain insights into the basic principles of formal language theory, which is foundational to fields like compilers, automata theory, and natural language processing.''')
                Button:
                    text: "5. Digraph Representation"
                    size_hint_y: None
                    height: 40
                    on_press: app.set_gramma_detail("Digraph Representation", "Representation", '''Digraph Representation in Formal Languages \n A digraph is a graph in which edges have a direction, indicated by arrows, pointing from one vertex to another. In the context of formal languages, digraphs are often used to represent transitions in finite state machines (FSMs), grammars, or automata. They provide a visual way to describe how systems evolve from one state to another based on input symbols. \n\n Key Concepts of Digraph Representation \n 1. Vertices (Nodes): \n The vertices or nodes in a digraph represent the states or symbols in the system. In the context of formal languages, these could represent states of a finite automaton, non-terminal symbols in a grammar, or characters in an alphabet. In an FSM, for example, each state is a vertex, and the edges between them represent transitions based on input symbols. \n 2. Edges (Arcs): \n The edges in a digraph represent transitions between states or symbols. These transitions are usually labeled with symbols that trigger the transition. In the case of finite automata, the edges represent the transition between states based on input symbols. \n 3. Directed Edges: \n Each edge in a digraph has a direction, which is typically represented with an arrow pointing from one vertex to another. This indicates that a particular action or transition occurs in one direction only. In formal language theory, directed edges show the flow of transitions between states, production rules in a grammar, or any rule-based operation in automata. \n\n Types of Digraphs in Formal Languages \n 1. Finite State Machines (FSM): \n 2. Deterministic Finite Automaton (DFA): In a DFA, each state has exactly one transition for every input symbol. A digraph is used to represent the states and transitions between them, where each edge is labeled with an input symbol. Non-deterministic Finite Automaton (NFA): In an NFA, a state may have multiple transitions for the same input symbol or even transitions without consuming any input (epsilon transitions). The digraph representation of an NFA includes multiple edges labeled with the same input or labeled as epsilon. \n  Example (DFA for recognizing strings with an even number of 0s):   \n States: {q0, q1} \n Alphabet: {0, 1} \n Start State: q0 \n Accepting States: {q0} \n   Transitions:    \n q0 --0--> q1 \n q0 --1--> q0  \n q1 --0--> q0  \n q1 --1--> q1  \n 3. Digraph Representation: \n q0 ----0----> q1  \n q0 ----1----> q0  \n q1 ----0----> q0  \n q1 ----1----> q1  \n 5. Context-Free Grammar (CFG): \n In a CFG, non-terminal symbols can be replaced with terminal or non-terminal symbols using production rules. Digraphs are used to represent the transitions between non-terminal symbols in a derivation process. \n The vertices represent the non-terminal symbols, and the directed edges represent the application of production rules to derive new strings. \n Digraph Representation: \n S --(S)--> S \n S --SS--> S \n S --ε--> \n Pushdown Automata (PDA):\n A pushdown automaton is a type of automaton that uses a stack to store symbols and has more computational power than a finite automaton. The digraph representation of a PDA involves both the state transitions and stack operations (push, pop). In a digraph for a PDA, the edges are labeled with both the input symbol and the stack operation (such as pushing or popping symbols). Structure and Use of Digraphs in Formal Languages\n Transition Diagrams for Automata:\n  In FSMs and PDAs, the digraph provides a clear, visual representation of how an automaton processes input symbols. The states are represented as vertices, and the transitions between states are directed edges labeled with input symbols.The start state is typically indicated with an arrow pointing to it from nowhere, and accepting states are shown with double circles.Derivation and Parsing in Grammars:\n  Digraphs are also used to represent the derivation steps in context-free and context-sensitive grammars. Each node represents a non-terminal symbol, and edges represent the application of production rules.In derivation trees, digraphs can illustrate how a string is built from the start symbol, with transitions showing how symbols are expanded into other symbols or terminals. Visualization of Language Constructs:\n  Digraphs are useful for visualizing the structure of a formal language, especially in complex grammars and automata. They help in understanding how strings are derived or processed through different states, and they provide insights into the computational steps involved in string recognition.\n  Example: Digraph Representation of a Pushdown Automaton (PDA) \n Consider a simple PDA that recognizes strings with balanced parentheses: States: {q0, q1, q_accept, q_reject} Input Alphabet: { ( ), ε } Stack Alphabet: { Z0, ( )} Start State: q0 \n Accepting State: q_accept \n Transitions:\n  (q0, (, Z0) -> (q0, (Z0)))''')

        BoxLayout:
            size_hint_y: None
            height: 60
            spacing: 750
            Button:
                text: ""
                background_normal: 'back_arrow.png'
                size_hint: None, None
                size: 90, 70
                on_press: app.root.current = 'home'
            Button:
                text: ""
                background_normal: 'practice_icon.png'
                size_hint: None, None
                size: 70, 70
                #on_press: app.root.current = app.display_question('grammars')
                on_press: app.root.current = 'grammarpratice'


<GrammarPracticeScreen>:
    BoxLayout:
        orientation: 'vertical'
        spacing: 20
        padding: 50
        canvas.before:
            Rectangle:
                source: "Background.png"
                pos: self.pos
                size: self.size

        Label:
            id: question_label  # ID matches Python code
            text: "Question will appear here."
            font_size: 20
            halign: 'center'
            valign: 'middle'
            text_size: self.size
            color: 0, 0, 0, 1
        
        ScrollView:
            do_scroll_x: False
            BoxLayout:
                orientation: 'vertical'
                size_hint_y: None
                height: self.minimum_height
                Button:
                    id: option_a  # ID matches Python code
                    text: "Option A"
                    size_hint_y: None
                    height: 40
                    on_press: app.check_answer('A')
                Button:
                    id: option_b
                    text: "Option B"
                    size_hint_y: None
                    height: 40
                    on_press: app.check_answer('B')
                Button:
                    id: option_c
                    text: "Option C"
                    size_hint_y: None
                    height: 40
                    on_press: app.check_answer('C')
                Button:
                    id: option_d
                    text: "Option D"
                    size_hint_y: None
                    height: 40
                    on_press: app.check_answer('D')
        Button:
            text: ""
            background_normal: 'lessonsImages/refreshicon.png'
            size_hint: None, None
            size: 90, 90
            on_press: app.refresh_screen('grammars')

<ScoreScreen>:
    BoxLayout:
        orientation: 'vertical'
        spacing: 20
        padding: 20

        canvas.before:
            Rectangle:
                source: "Background.png"  
                pos: self.pos
                size: self.size

        Label:
            id: score_label
            text: "Your Score: 0"
            color:1 ,0 ,0 ,1
            font_size: 24
        # Call reset function
        Button:
            text: ""
            background_normal: 'ScoreIcon.png'
            size_hint: None, None
            align:'left'
            size: 500, 500
            on_press: app.reset_quiz(); app.root.current = 'home'

        



        